---
typora-root-url: F:\Typora Pictures
---

# （Task4）结构体，联合体，枚举，指针和函数

## 结构体

### 结构变量

#### 应用方面

既包含字符串又包含数字，同时保持个信息的独立

#### 结构声明

```c
struct book {
    char title{MAXTITL};
    char author{MAXAUTL};
    float value;
};
```

* 并未创建实际的数据对象，只是描述了该对象由什么组成。关键字`struct`表明后边跟的是结构，后边是个可选的标记（如这段代码中的`book`）。后边可以使用该标记来引用该结构。

* 如`struct book library;`把`library`声明为一个使用`book`结构布局的变量
* 用一对花括号括起来的结构是结构成员列表，每一个成员都有自己的声明来描述
* 成员可以是任意一种C的数据类型，甚至是其他结构。
* `MAXTITL`表示`title`这个数组的元素个数
* 声明可以在函数外部和内部
* 结构的标记名是可选的，但是在一处定义结构布局，另一处定义实际结构变量的时候必须使用标记

#### 定义结构变量

* `struct book library;`使用`book`模板的结构体

* 相当于上文声明之后在花括号后边加一个`library;`

* 声明和定义可以组合成一个步骤，不用写结构标记

  ```c
  struct {
      ......;
  } library;
  ```

#### 初始化结构

```c
struct book library = {
    "The Pious ......",
    "Renee Vivotee",
    1.95
};
```

各个初始化项用逗号分隔，类似初始化数组

#### 访问结构成员

**结构成员运算符**`.`

* `library.value`表示党文`library`中的`value`部分，相当于一个浮点变量

* `.`的运算优先级比`&`高，因此可以`&library.value`

#### 结构初始化器

`struct book surprise = { .value = 10.99 };`只初始化value

也可以任意顺序初始化。若不写元素，就初始化上一个元素之后的元素（类似数组）

对于特定成员的最后一次赋值才是实际的值

### 结构数组

`struct book library [MAXBKS];`book类型的结构数组

#### 访问

`library[0].value`	*注意下标的位置*

### 嵌套结构

```c
struct names {
    char first[LEN];
    char last[LEN];
};

struct guy {
    struct name handle;
    ......
};
```

访问嵌套结构中的成员需要两次点运算符`fellow.handle.first`

### 结构和指针，函数

`struct guy * him;`

`him = &barney;`

与数组不同，需要取地址符

#### 指针访问结构的成员

用`->`运算符

`(*him).income`就是`him->income`

#### 函数传递结构信息

##### 传递结构成员

`sum(stan.bankfund, stan.savefund)`

或者传指针

##### 传递结构的地址

`sum(&stan)`访问了叫stan的结构的地址

函数的声明`double sum(const struct funs * money);`

(funs是stan的结构类型)

##### 传递结构

`double sum(struct funds moolah);`

`sum(stan)`

moolah是一个自动变量，函数运用副本来运算

### 其他结构特性

结构之间赋值`o_data = n_data;`每个成员的值赋给对应成员



## 联合体

### 简介

在同一个内存空间存储不同的数据类型

**声明**

~~~c
union hold {
    int digit;
    double bigfl;
    char letter;
};
~~~

**定义**

`union hold fit;`

`union hold save[10];`

`union hold * pu;`

**初始化**

```C
union hold valA;
valA.letter = 'R';
union hole valB = valA;
union hold valC = {88};//初始化联合的digit成员
union hold valD = {.bigfl = 118.2};//指定初始化器
```



### 使用联合

1. union中可以定义多个成员，union大小由最大的成员的大小来决定

2. union成员共享同一块大小的内存，一次只能使用其中的一个成员

3. 对某一个成员赋值，会覆盖其他成员的值（前提是成员所占字节数相同，当不同时，指挥覆盖相应字节上的值）

4. union的存放顺序是所有成员都从低地址开始存放的

**指针访问**

同结构体，用`->`运算符

## 枚举

枚举类型为`int`，目的是为了提高程序可读性

`enum spectrum {red, orange, yellow, green};`

`enum spectrum color;`

第一句创建了标记名spectrum，第二句声明color为spectrum类型变量

### 默认值

枚举默认值为0，1，2..……即red代表0，orange代表1……

### 赋值

`enum levels{low = 100, medium, high = 200};`未指定时就是+1，比如medium就是101

### 用法

为了让程序更加直观，相当于整数

## `argc` 与`argv`

arg：arguments
argc：argument counter
argv：argument vector
argc 是 argument count的缩写，表示传入main函数的参数个数；

argv 是 argument vector的缩写，表示传入main函数的参数序列或指针，并且第一个参数argv[0]一定是程序的名称，并且包含了程序所在的完整路径，所以确切的说需要我们输入的main函数的参数个数应该是argc-1个

argc 是指命令行输入参数的个数，argv存储了所有的命令行参数。

# 基础任务

## malloc函数

`malloc( )`函数会找到合适的空闲内存块，在程序运行的时候分配更多的内存

~~~c
int *p;
p = (int *)malloc(30 * sizeof(int));
~~~

为30个int类型的值请求内存空间，并设置了一个指针指向该位置

可以用p[0]访问该块的首元素，p[1]访问第二个

***在执行后要***`free()`

`free(p);`

**原因**：动态分配的内存数量只会增加不会减少，除非有free；否则容易发生内存泄漏

## 结构体指针的`->`运算符

`(*him).income`就是`him->income`

## 链表

不用事先确定存储空间，而是根据需要开辟内存单元

**结构**：第0个结点称为头结点，存放第一个结点的首地址，没有数据，只有一个指针变量。以后的每个结点都有两个域，一个是数据域，一个是指针域，存放下一结点的首地址。最后一个结点的指针域为NULL

链表都有头指针，一般以head表示，存放的是一个地址

### 创建

~~~c
typedef struct Node{
	int data;				//数据域 
	struct Node *next;		//指针域 
};
~~~

用`typedef`的原因：这样定义可以直接用`LinkList *a`定义结构体变量

### 链表初始化

作用：生成头指针，便于后续函数调用操作

~~~c
//创建链表 
struct Node* createList(){
	struct Node* headNode = (struct Node*)malloc(sizeof(struct Node));
	//headNode  成为了结构体变量
	//初始化
	headNode->data = 1;
	headNode->next = NULL;
	return headNode;
}
~~~

### 创建结点

~~~c
//创建结点 
struct Node* creatNode(int data){
	struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
	newNode->data = data;
	newNode->next = NULL;
	return newNode;
}
~~~

### 打印链表

~~~c
void printList(struct Node* headNode){
	struct Node* pMove = headNode->next;
	while (pMove) {
		printf("%d",pMove->data);
		pMove = pMove->next;
	}
	printf("\n");
}
~~~



### 插入结点-表头法

~~~c
void insertNodeByHead(struct Node* headNode,int data){
	//创建插入的结点
	struct Node* newNode = createNode(data);
	newNode->next = headNode->next;
	headNode->next = newNode; 
} 
~~~

### 链表的删除：指定位置删除

~~~c
void deleteNodeByAppoin(struct Node* headNode, int posData){
	struct Node* posNode = headNode->next;
	struct Node* posNodeFront = headNode;
	if (posNode == NULL){
		printf("无法删除链表为空\n");
	}
	else{
		while (posNode->data != posData){
			posNodeFront = posNode;
			posNode = posNodeFront->next;
			if(posNode == NULL){
				printf("没有找到相关信息，无法删除\n");
				return;
			}
		}
		posNodeFront->next = posNode->next;
		free(posNode);
	}
}
~~~

### 自定义数据域data

不要把结构体写进链表，在外边声明结构体，在数据域处定义结构体。

## debug

添加断点，开启调试，程序会运行到断点之前，然后“下一步”（函数要单步进入）。添加查看可以查看变量的值

# 提高任务

## 编程实现：单链表读取用户输入的整数

```C
#include <stdio.h>
#include <stdlib.h>
 
typedef struct LNode{
	int data;		/* 链表数据 */
	struct LNode* next;	/* 链表指针 */
}LNode,*LinkList;
 
int main()
{
	int i,data,count=0;
	LinkList L;
	LinkList p;
	LinkList q;
	L = (LinkList)malloc(sizeof(LNode));
	L->next = NULL;	/* 头结点 */
    
	q = L;
	printf("请输入你的任意个整数,用空格隔开,输入大写字母Q表示结束\n");
	do                             /* 创建链表结点，顺序输入元素 */
	{    
		scanf("%d",&data);
		p =  (LinkList)malloc(sizeof(LNode));
		p->data =data;
		p->next = NULL;q->next = p;q = p;
		count++;
	}while(getchar() != 'Q');
	p = L->next;    /* p指针指向第一个结点 */
	q = L->next;
	i=1;
	printf("你输入的整数是:\n");
	while(i < count)                /* 按序输出链表元素 */
	{
		printf("NO.%d:",i);
		printf("%5d\t",q->data);
		q = q->next;
		if(0 == i%4)
		printf("\n");
		i++;
	}
	printf("\n");
	/* 释放空间 */
	p = L->next;
	i=1;
	while(i++ <= count)                    
	{
		q = p;
		p = p->next;
		free(q);
	} 
	return 0;
}
```

## 逆置链表

~~~c
#include <stdio.h>
#include <stdlib.h>
 
typedef struct LNode{
	int data;		/* 链表数据 */
	struct LNode* next;	/* 链表指针 */
}LNode,*LinkList;

//链表的逆置
LNode *ReverseList(LNode *phead)
{
	LNode *p, *q, *r;
 
	p = phead;
	q=r=NULL;
 
	while(p)
	{
		q = p->next;
		p->next = r;
		r = p;
		p = q;
	}
	return r;
}
 
//输出链表
void ShowList(LNode *phead)
{
	LNode *p;
 
	p = phead;
	while(p)
	{
		printf("%d ", p->data);
		p = p->next;
	}
	printf("\n");
}

 
int main()
{
	int i,data,count=0;
	LinkList L;
	LinkList p;
	LinkList q;
	L = (LinkList)malloc(sizeof(LNode));
	L->next = NULL;	/* 头结点 */
    
	q = L;
	printf("请输入你的任意个整数,用空格隔开,输入大写字母Q表示结束\n");
	do                             /* 创建链表结点，顺序输入元素 */
	{    
		scanf("%d",&data);
		p =  (LinkList)malloc(sizeof(LNode));
		p->data =data;
		p->next = NULL;q->next = p;q = p;
		count++;
	}while(getchar() != 'Q');
	p = L->next;    /* p指针指向第一个结点 */
	q = L->next;
	i=1;
	
	printf("你输入的整数是:\n");	
	ShowList(p);	
	printf("\n");
	
	//逆置
	p =  ReverseList(p);
	
	printf("逆置后为\n");
	ShowList(p);
	 
	/* 释放空间 */
	p = L->next;
	i=1;
	while(i++ <= count)                    
	{
		q = p;
		p = p->next;
		free(q);
	} 
	return 0;
}
~~~

*存在疑问：输出多了一位数（输入为1 2 3 Q，输出了1 2 3 3）*

# LeetCode刷题

## 344

~~~c
void reverseString(char* s, int sSize){
    for( int i = 0; i < sSize / 2; i++ ){
        char temp = s[i];
        s[i] = s[sSize-1-i];
        s[sSize-1-i] = temp;
    }
}
~~~

## 1

```c
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* twoSum(int* nums, int numsSize, int target, int* returnSize){
    int i,j;
    int *result=NULL;
    *returnSize=2;
    for(i=0;i<numsSize-1;i++)
    {
        for(j=i+1;j<numsSize;j++)
        {
            if(nums[i]+nums[j]==target)
            {
                 result=(int*)malloc(sizeof(int)*2);
                 result[0]=i;
                 result[1]=j;
                 return result;
            }
        }
    }
    return result;
}
```



## 15

思路

1. 数组为空或者长度小于3：直接返回空

2. 对数组排序。

3. 对于排序后数组

   * 遍历的时候遇到相同的数字直接跳过

   * 三组嵌套`for`循环`(i,j,k)`，分别代表选择的第1，2，3个数
     * 其中`i`从`0`到`numsSize-2`，遇到`num[i]>0`直接返回
     * `j`从`i+1`到`numsSize-1`
     * `k`从`j+1`到`numsSize`

   * 遍历过程中如果`nums[i] + nums[j] + nums[k] == 0`则申请一个三个int的空间用来存储这组数据

4. 最后返回这些数据

不会写代码……题解的双指针看不太懂

## 371

~~~c
int getSum(int a, int b){
    
    while (b != 0) { 
        unsigned int carry = (unsigned int)(a & b) << 1; 
        a = a ^ b;
        b = carry; 
        }
        return a;
}
~~~



## 35

~~~c
int searchInsert(int* nums, int numsSize, int target){
    int left = 0, right = numsSize - 1;
    while(left <= right){
        int mid = ((right-left)/2)+left;
        if(target <= nums[mid]){
            right = mid - 1;
        }
        else{
            left = mid + 1;
        }
    }
    return left;
}
~~~



## 206

~~~c
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */


struct ListNode* reverseList(struct ListNode* head){
	struct ListNode *p, *q, *r;
 
	p = head;
	q=r=NULL;
 
	while(p)
	{
		q = p->next;
		p->next = r;
		r = p;
		p = q;
	}
	return r;
}
~~~

